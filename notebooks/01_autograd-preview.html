<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.8.24">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


    <title>01.3 Automatic Differentiation</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
      /* CSS for syntax highlighting */
      html { -webkit-text-size-adjust: 100%; }
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
        }
      pre.numberSource { margin-left: 3em;  padding-left: 4px; }
      div.sourceCode
        {   }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "../index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="../site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-b651517ce65839d647a86e2780455cfb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a910bf525923a870f448fa2c311c8cf7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script> 
        <link rel="stylesheet" href="../styles.css">
      </head>

  <body class="quarto-notebook quarto-light">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> 01.3 Automatic Differentiation</h6>

            <a href="../notebooks/01_autograd.ipynb" class="btn btn-primary quarto-download-embed" download="01_autograd.ipynb">Download Notebook</a>
          </div>

     <header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">01.3 Automatic Differentiation</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
        
        <div class="quarto-title-meta">

                
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      </div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#a-simple-function" id="toc-a-simple-function" class="nav-link active" data-scroll-target="#a-simple-function">A Simple Function</a></li>
  <li><a href="#backward-for-non-scalar-variables" id="toc-backward-for-non-scalar-variables" class="nav-link" data-scroll-target="#backward-for-non-scalar-variables">Backward for Non-Scalar Variables</a></li>
  <li><a href="#detaching-computation" id="toc-detaching-computation" class="nav-link" data-scroll-target="#detaching-computation">Detaching Computation</a></li>
  <li><a href="#gradients-and-python-control-flow" id="toc-gradients-and-python-control-flow" class="nav-link" data-scroll-target="#gradients-and-python-control-flow">Gradients and Python Control Flow</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      

       <div id="4144c129" class="cell markdown">
<p>Recall from Section Calculus that calculating derivatives is the crucial step in all the optimization algorithms that we will use to train deep networks. While the calculations are straightforward, working them out by hand can be tedious and error-prone, and these issues only grow as our models become more complex.</p>
<p>Fortunately all modern deep learning frameworks take this work off our plates by offering <em>automatic differentiation</em> (often shortened to <em>autograd</em>). As we pass data through each successive function, the framework builds a <em>computational graph</em> that tracks how each value depends on others. To calculate derivatives, automatic differentiation works backwards through this graph applying the chain rule. The computational algorithm for applying the chain rule in this fashion is called <em>backpropagation</em>.</p>
<p>While autograd libraries have become a hot concern over the past decade, they have a long history. In fact the earliest references to autograd date back over half of a century :cite:<code>Wengert.1964</code>. The core ideas behind modern backpropagation date to a PhD thesis from 1980 :cite:<code>Speelpenning.1980</code> and were further developed in the late 1980s :cite:<code>Griewank.1989</code>. While backpropagation has become the default method for computing gradients, it is not the only option. For instance, the Julia programming language employs forward propagation :cite:<code>Revels.Lubin.Papamarkou.2016</code>. Before exploring methods, let’s first master the autograd package.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [2]:</pre></div><div id="130439cd" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:08.286501Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:08.285693Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.052257Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.050994Z&quot;}}" data-origin_pos="3" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div></div>
<div id="e2ab3850" class="cell markdown">
<section id="a-simple-function" class="level2">
<h2 class="anchored" data-anchor-id="a-simple-function">A Simple Function</h2>
<p>Let’s assume that we are interested in (<strong>differentiating the function <span class="math inline">\(y = 2\mathbf{x}^{\top}\mathbf{x}\)</span> with respect to the column vector <span class="math inline">\(\mathbf{x}\)</span>.</strong>) To start, we assign <code>x</code> an initial value.</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [4]:</pre></div><div id="4253cfab" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.056833Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.055871Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.084858Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.083727Z&quot;}}" data-origin_pos="8" data-outputid="9f833a8e-1600-434a-d323-1f7e092a2e26" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.arange(<span class="fl">4.0</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>x</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>tensor([0., 1., 2., 3.])</code></pre>
</div>
</div></div>
<div id="e75614b0" class="cell markdown">
<p>[<strong>Before we calculate the gradient of <span class="math inline">\(y\)</span> with respect to <span class="math inline">\(\mathbf{x}\)</span>, we need a place to store it.</strong>] In general, we avoid allocating new memory every time we take a derivative because deep learning requires successively computing derivatives with respect to the same parameters a great many times, and we might risk running out of memory. Note that the gradient of a scalar-valued function with respect to a vector <span class="math inline">\(\mathbf{x}\)</span> is vector-valued with the same shape as <span class="math inline">\(\mathbf{x}\)</span>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [6]:</pre></div><div id="2a001d1e" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.088716Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.087816Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.092878Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.091740Z&quot;}}" data-origin_pos="13" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Can also create x = torch.arange(4.0, requires_grad=True)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>x.requires_grad_(<span class="va">True</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>x.grad  <span class="co"># The gradient is None by default</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div></div>
<div id="2e74bc02" class="cell markdown">
<p>(<strong>We now calculate our function of <code>x</code> and assign the result to <code>y</code>.</strong>)</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [8]:</pre></div><div id="6e3bd777" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.096336Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.095772Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.105236Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.104075Z&quot;}}" data-origin_pos="17" data-outputid="d21f974f-cc00-4ef3-9a39-2bdd28d5c118" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> torch.dot(x, x)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>y</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>tensor(28., grad_fn=&lt;MulBackward0&gt;)</code></pre>
</div>
</div></div>
<div id="c3067490" class="cell markdown">
<p>[<strong>We can now take the gradient of <code>y</code> with respect to <code>x</code></strong>] by calling its <code>backward</code> method. Next, we can access the gradient via <code>x</code>’s <code>grad</code> attribute.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [10]:</pre></div><div id="21b134ae" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.108600Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.108011Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.160854Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.159702Z&quot;}}" data-origin_pos="25" data-outputid="879af498-f917-43e8-fe94-1781c2920d80" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>y.backward()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>x.grad</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>tensor([ 0.,  4.,  8., 12.])</code></pre>
</div>
</div></div>
<div id="17d1390b" class="cell markdown">
<p>(<strong>We already know that the gradient of the function <span class="math inline">\(y = 2\mathbf{x}^{\top}\mathbf{x}\)</span> with respect to <span class="math inline">\(\mathbf{x}\)</span> should be <span class="math inline">\(4\mathbf{x}\)</span>.</strong>) We can now verify that the automatic gradient computation and the expected result are identical.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [12]:</pre></div><div id="5030e37d" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.164665Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.163930Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.171033Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.169923Z&quot;}}" data-origin_pos="30" data-outputid="eade007f-d646-4136-fa90-aef1da04a860" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>x.grad <span class="op">==</span> <span class="dv">4</span> <span class="op">*</span> x</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>tensor([True, True, True, True])</code></pre>
</div>
</div></div>
<div id="da440e48" class="cell markdown">
<p>[<strong>Now let’s calculate another function of <code>x</code> and take its gradient.</strong>] Note that PyTorch does not automatically reset the gradient buffer when we record a new gradient. Instead, the new gradient is added to the already-stored gradient. This behavior comes in handy when we want to optimize the sum of multiple objective functions. To reset the gradient buffer, we can call <code>x.grad.zero_()</code> as follows:</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [14]:</pre></div><div id="add5cf4b" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.174691Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.173957Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.181847Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.180759Z&quot;}}" data-origin_pos="37" data-outputid="6f404041-8eb3-47ac-fa2d-581c20fa8e30" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>x.grad.zero_()  <span class="co"># Reset the gradient</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x.<span class="bu">sum</span>()</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>y.backward()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>x.grad</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>tensor([1., 1., 1., 1.])</code></pre>
</div>
</div></div>
<div id="8bdd4c0c" class="cell markdown">
<section id="backward-for-non-scalar-variables" class="level2">
<h2 class="anchored" data-anchor-id="backward-for-non-scalar-variables">Backward for Non-Scalar Variables</h2>
<p>When <code>y</code> is a vector, the most natural representation of the derivative of <code>y</code> with respect to a vector <code>x</code> is a matrix called the <em>Jacobian</em> that contains the partial derivatives of each component of <code>y</code> with respect to each component of <code>x</code>. Likewise, for higher-order <code>y</code> and <code>x</code>, the result of differentiation could be an even higher-order tensor.</p>
<p>While Jacobians do show up in some advanced machine learning techniques, more commonly we want to sum up the gradients of each component of <code>y</code> with respect to the full vector <code>x</code>, yielding a vector of the same shape as <code>x</code>. For example, we often have a vector representing the value of our loss function calculated separately for each example among a <em>batch</em> of training examples. Here, we just want to (<strong>sum up the gradients computed individually for each example</strong>).</p>
</section>
</div>
<div id="9dda7124" class="cell markdown">
<p>Because deep learning frameworks vary in how they interpret gradients of non-scalar tensors, PyTorch takes some steps to avoid confusion. Invoking <code>backward</code> on a non-scalar elicits an error unless we tell PyTorch how to reduce the object to a scalar. More formally, we need to provide some vector <span class="math inline">\(\mathbf{v}\)</span> such that <code>backward</code> will compute <span class="math inline">\(\mathbf{v}^\top \partial_{\mathbf{x}} \mathbf{y}\)</span> rather than <span class="math inline">\(\partial_{\mathbf{x}} \mathbf{y}\)</span>. This next part may be confusing, but for reasons that will become clear later, this argument (representing <span class="math inline">\(\mathbf{v}\)</span>) is named <code>gradient</code>. For a more detailed description, see Yang Zhang’s <a href="https://zhang-yang.medium.com/the-gradient-argument-in-pytorchs-backward-function-explained-by-examples-68f266950c29">Medium post</a>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [17]:</pre></div><div id="1baa40bd" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.185096Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.184685Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.192537Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.191435Z&quot;}}" data-origin_pos="45" data-outputid="4178aafa-6afd-4b6d-a863-f258a21b5cb2" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x.grad.zero_()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x <span class="op">*</span> x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>y.backward(gradient<span class="op">=</span>torch.ones(<span class="bu">len</span>(y)))  <span class="co"># Faster: y.sum().backward()</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>x.grad</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>tensor([0., 2., 4., 6.])</code></pre>
</div>
</div></div>
<div id="ffbd2c9d" class="cell markdown">
<section id="detaching-computation" class="level2">
<h2 class="anchored" data-anchor-id="detaching-computation">Detaching Computation</h2>
<p>Sometimes, we wish to [<strong>move some calculations outside of the recorded computational graph.</strong>] For example, say that we use the input to create some auxiliary intermediate terms for which we do not want to compute a gradient. In this case, we need to <em>detach</em> the respective computational graph from the final result. The following toy example makes this clearer: suppose we have <code>z = x * y</code> and <code>y = x * x</code> but we want to focus on the <em>direct</em> influence of <code>x</code> on <code>z</code> rather than the influence conveyed via <code>y</code>. In this case, we can create a new variable <code>u</code> that takes the same value as <code>y</code> but whose <em>provenance</em> (how it was created) has been wiped out. Thus <code>u</code> has no ancestors in the graph and gradients do not flow through <code>u</code> to <code>x</code>. For example, taking the gradient of <code>z = x * u</code> will yield the result <code>u</code>, (not <code>3 * x * x</code> as you might have expected since <code>z = x * x * x</code>).</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [19]:</pre></div><div id="107ac041" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.196001Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.195456Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.203246Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.202155Z&quot;}}" data-origin_pos="50" data-outputid="2bc6d5ad-21fa-425f-c747-90971ab94681" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>x.grad.zero_()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> x <span class="op">*</span> x</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> y.detach()</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> u <span class="op">*</span> x</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>z.<span class="bu">sum</span>().backward()</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>x.grad <span class="op">==</span> u</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>tensor([True, True, True, True])</code></pre>
</div>
</div></div>
<div id="e0378e1f" class="cell markdown">
<p>Note that while this procedure detaches <code>y</code>’s ancestors from the graph leading to <code>z</code>, the computational graph leading to <code>y</code> persists and thus we can calculate the gradient of <code>y</code> with respect to <code>x</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [21]:</pre></div><div id="cb8c674b" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.206880Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.206001Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.213592Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.212476Z&quot;}}" data-origin_pos="55" data-outputid="18ebe0df-2c54-47f7-b295-d9d84535a259" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>x.grad.zero_()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>y.<span class="bu">sum</span>().backward()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>x.grad <span class="op">==</span> <span class="dv">2</span> <span class="op">*</span> x</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>tensor([True, True, True, True])</code></pre>
</div>
</div></div>
<div id="76f056ce" class="cell markdown">
<section id="gradients-and-python-control-flow" class="level2">
<h2 class="anchored" data-anchor-id="gradients-and-python-control-flow">Gradients and Python Control Flow</h2>
<p>So far we reviewed cases where the path from input to output was well defined via a function such as <code>z = x * x * x</code>. Programming offers us a lot more freedom in how we compute results. For instance, we can make them depend on auxiliary variables or condition choices on intermediate results. One benefit of using automatic differentiation is that [<strong>even if</strong>] building the computational graph of (<strong>a function required passing through a maze of Python control flow</strong>) (e.g., conditionals, loops, and arbitrary function calls), (<strong>we can still calculate the gradient of the resulting variable.</strong>) To illustrate this, consider the following code snippet where the number of iterations of the <code>while</code> loop and the evaluation of the <code>if</code> statement both depend on the value of the input <code>a</code>.</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [23]:</pre></div><div id="a83327c2" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.218214Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.217554Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.222956Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.221858Z&quot;}}" data-origin_pos="60" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(a):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> a <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> b.norm() <span class="op">&lt;</span> <span class="dv">1000</span>:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> b <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b.<span class="bu">sum</span>() <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> b</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> <span class="dv">100</span> <span class="op">*</span> b</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div></div>
<div id="189f6785" class="cell markdown">
<p>Below, we call this function, passing in a random value, as input. Since the input is a random variable, we do not know what form the computational graph will take. However, whenever we execute <code>f(a)</code> on a specific input, we realize a specific computational graph and can subsequently run <code>backward</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [25]:</pre></div><div id="c5ef0264" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.227364Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.226919Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.232880Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.231773Z&quot;}}" data-origin_pos="65" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.randn(size<span class="op">=</span>(), requires_grad<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> f(a)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>d.backward()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div></div>
<div id="51065133" class="cell markdown">
<p>Even though our function <code>f</code> is, for demonstration purposes, a bit contrived, its dependence on the input is quite simple: it is a <em>linear</em> function of <code>a</code> with piecewise defined scale. As such, <code>f(a) / a</code> is a vector of constant entries and, moreover, <code>f(a) / a</code> needs to match the gradient of <code>f(a)</code> with respect to <code>a</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [27]:</pre></div><div id="ab14ef91" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:26:10.237298Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:26:10.236886Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:26:10.243577Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:26:10.242480Z&quot;}}" data-origin_pos="70" data-outputid="0afb1308-dabe-4f65-9cb2-6a87a39dd59c" data-tab="[&quot;pytorch&quot;]">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>a.grad <span class="op">==</span> d <span class="op">/</span> a</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>tensor(True)</code></pre>
</div>
</div></div>
<div id="a992f28c" class="cell markdown">
<p>Dynamic control flow is very common in deep learning. For instance, when processing text, the computational graph depends on the length of the input. In these cases, automatic differentiation becomes vital for statistical modeling since it is impossible to compute the gradient <em>a priori</em>.</p>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>You have now gotten a taste of the power of automatic differentiation. The development of libraries for calculating derivatives both automatically and efficiently has been a massive productivity booster for deep learning practitioners, liberating them so they can focus on less menial. Moreover, autograd lets us design massive models for which pen and paper gradient computations would be prohibitively time consuming. Interestingly, while we use autograd to <em>optimize</em> models (in a statistical sense) the <em>optimization</em> of autograd libraries themselves (in a computational sense) is a rich subject of vital interest to framework designers. Here, tools from compilers and graph manipulation are leveraged to compute results in the most expedient and memory-efficient manner.</p>
<p>For now, try to remember these basics: (i) attach gradients to those variables with respect to which we desire derivatives; (ii) record the computation of the target value; (iii) execute the backpropagation function; and (iv) access the resulting gradient.</p>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<ol type="1">
<li>Why is the second derivative much more expensive to compute than the first derivative?</li>
<li>After running the function for backpropagation, immediately run it again and see what happens. Investigate.</li>
<li>In the control flow example where we calculate the derivative of <code>d</code> with respect to <code>a</code>, what would happen if we changed the variable <code>a</code> to a random vector or a matrix? At this point, the result of the calculation <code>f(a)</code> is no longer a scalar. What happens to the result? How do we analyze this?</li>
<li>Let <span class="math inline">\(f(x) = \sin(x)\)</span>. Plot the graph of <span class="math inline">\(f\)</span> and of its derivative <span class="math inline">\(f'\)</span>. Do not exploit the fact that <span class="math inline">\(f'(x) = \cos(x)\)</span> but rather use automatic differentiation to get the result.</li>
<li>Let <span class="math inline">\(f(x) = ((\log x^2) \cdot \sin x) + x^{-1}\)</span>. Write out a dependency graph tracing results from <span class="math inline">\(x\)</span> to <span class="math inline">\(f(x)\)</span>.</li>
<li>Use the chain rule to compute the derivative <span class="math inline">\(\frac{df}{dx}\)</span> of the aforementioned function, placing each term on the dependency graph that you constructed previously.</li>
<li>Given the graph and the intermediate derivative results, you have a number of options when computing the gradient. Evaluate the result once starting from <span class="math inline">\(x\)</span> to <span class="math inline">\(f\)</span> and once from <span class="math inline">\(f\)</span> tracing back to <span class="math inline">\(x\)</span>. The path from <span class="math inline">\(x\)</span> to <span class="math inline">\(f\)</span> is commonly known as <em>forward differentiation</em>, whereas the path from <span class="math inline">\(f\)</span> to <span class="math inline">\(x\)</span> is known as backward differentiation.</li>
<li>When might you want to use forward, and when backward, differentiation? Hint: consider the amount of intermediate data needed, the ability to parallelize steps, and the size of matrices and vectors involved.</li>
</ol>
</section>
</div>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>  </div> <!-- /content --> 
  
</body></html>