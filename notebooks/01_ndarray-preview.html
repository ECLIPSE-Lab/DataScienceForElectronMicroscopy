<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.8.14">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


    <title>01.1 Data Manipulation</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
      /* CSS for syntax highlighting */
      html { -webkit-text-size-adjust: 100%; }
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
        }
      pre.numberSource { margin-left: 3em;  padding-left: 4px; }
      div.sourceCode
        {   }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "../index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="../site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-98bfa626b1068186620cc14e15ad040c.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d65045e6db30216e1e35d0086a27e8e5.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script> 
        <link rel="stylesheet" href="../styles.css">
      </head>

  <body class="quarto-notebook quarto-light">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> 01.1 Data Manipulation</h6>

            <a href="../notebooks/01_ndarray.ipynb" class="btn btn-primary quarto-download-embed" download="01_ndarray.ipynb">Download Notebook</a>
          </div>

     <header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">01.1 Data Manipulation</h1>
          </div>

    
    <div class="quarto-title-meta-container">
      <div class="quarto-title-meta-column-start">
        
        <div class="quarto-title-meta">

                
          
                
              </div>
      </div>
      <div class="quarto-title-meta-column-end quarto-other-formats-target">
      </div>
    </div>



    <div class="quarto-other-links-text-target">
    </div>  </div>
</header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#indexing-and-slicing" id="toc-indexing-and-slicing" class="nav-link active" data-scroll-target="#indexing-and-slicing">Indexing and Slicing</a></li>
  <li><a href="#operations" id="toc-operations" class="nav-link" data-scroll-target="#operations">Operations</a></li>
  <li><a href="#broadcasting" id="toc-broadcasting" class="nav-link" data-scroll-target="#broadcasting">Broadcasting</a></li>
  <li><a href="#saving-memory" id="toc-saving-memory" class="nav-link" data-scroll-target="#saving-memory">Saving Memory</a></li>
  <li><a href="#conversion-to-other-python-objects" id="toc-conversion-to-other-python-objects" class="nav-link" data-scroll-target="#conversion-to-other-python-objects">Conversion to Other Python Objects</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      

       <div id="0de623d7" class="cell markdown">
<p>In order to get anything done, we need some way to store and manipulate data. Generally, there are two important things we need to do with data: (i) acquire them; and (ii) process them once they are inside the computer. There is no point in acquiring data without some way to store it, so to start, let’s get our hands dirty with <span class="math inline">\(n\)</span>-dimensional arrays, which we also call <em>tensors</em>. If you already know the NumPy scientific computing package, this will be a breeze. For all modern deep learning frameworks, the <em>tensor class</em> (<code>ndarray</code> in MXNet, <code>Tensor</code> in PyTorch and TensorFlow) resembles NumPy’s <code>ndarray</code>, with a few killer features added. First, the tensor class supports automatic differentiation. Second, it leverages GPUs to accelerate numerical computation, whereas NumPy only runs on CPUs. These properties make neural networks both easy to code and fast to run.</p>
<section id="getting-started" class="level2">
<h2 class="anchored" data-anchor-id="getting-started">Getting Started</h2>
</section>
</div>
<div id="084dc517" class="cell markdown">
<p>(<strong>To start, we import the PyTorch library. Note that the package name is <code>torch</code>.</strong>)</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [3]:</pre></div><div id="01fa8e58" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:55.152236Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:55.151500Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.051589Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.050409Z&quot;}}" data-origin_pos="6" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div>
<div id="8d828de8" class="cell markdown">
<p>[<strong>A tensor represents a (possibly multidimensional) array of numerical values.</strong>] In the one-dimensional case, i.e., when only one axis is needed for the data, a tensor is called a <em>vector</em>. With two axes, a tensor is called a <em>matrix</em>. With <span class="math inline">\(k &gt; 2\)</span> axes, we drop the specialized names and just refer to the object as a <span class="math inline">\(k^\textrm{th}\)</span>-<em>order tensor</em>.</p>
</div>
<div id="1a471639" class="cell markdown">
<p>PyTorch provides a variety of functions for creating new tensors prepopulated with values. For example, by invoking <code>arange(n)</code>, we can create a vector of evenly spaced values, starting at 0 (included) and ending at <code>n</code> (not included). By default, the interval size is <span class="math inline">\(1\)</span>. Unless otherwise specified, new tensors are stored in main memory and designated for CPU-based computation.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [6]:</pre></div><div id="b6aa30a9" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.056039Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.055276Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.089028Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.088195Z&quot;}}" data-origin_pos="14" data-outputid="1306a523-f421-41ab-a4ae-cecba676f704" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.arange(<span class="dv">12</span>, dtype<span class="op">=</span>torch.float32)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>tensor([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])</code></pre>
</div>
</div></div>
<div id="1a12b5d8" class="cell markdown">
<p>Each of these values is called an <em>element</em> of the tensor. The tensor <code>x</code> contains 12 elements. We can inspect the total number of elements in a tensor via its <code>numel</code> method.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [8]:</pre></div><div id="640cadaf" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.093138Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.092473Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.098450Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.097452Z&quot;}}" data-origin_pos="21" data-outputid="17fc0da2-56d1-4bb6-e2e3-96723cd36338" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>x.numel()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>12</code></pre>
</div>
</div></div>
<div id="d50c7483" class="cell markdown">
<p>(<strong>We can access a tensor’s <em>shape</em></strong>) (the length along each axis) by inspecting its <code>shape</code> attribute. Because we are dealing with a vector here, the <code>shape</code> contains just a single element and is identical to the size.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [10]:</pre></div><div id="6e0a9616" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.102194Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.101575Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.107424Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.106501Z&quot;}}" data-origin_pos="24" data-outputid="6d10f079-7c31-4266-b659-082d25222563" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>x.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>torch.Size([12])</code></pre>
</div>
</div></div>
<div id="5c60413a" class="cell markdown">
<p>We can [<strong>change the shape of a tensor without altering its size or values</strong>], by invoking <code>reshape</code>. For example, we can transform our vector <code>x</code> whose shape is (12,) to a matrix <code>X</code> with shape (3, 4). This new tensor retains all elements but reconfigures them into a matrix. Notice that the elements of our vector are laid out one row at a time and thus <code>x[3] == X[0, 3]</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [12]:</pre></div><div id="6092207c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.111467Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.110749Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.117759Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.116917Z&quot;}}" data-origin_pos="26" data-outputid="fae038b7-05a7-4669-c470-4398985c419e" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> x.reshape(<span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>tensor([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.],
        [ 8.,  9., 10., 11.]])</code></pre>
</div>
</div></div>
<div id="2d2e1706" class="cell markdown">
<p>Note that specifying every shape component to <code>reshape</code> is redundant. Because we already know our tensor’s size, we can work out one component of the shape given the rest. For example, given a tensor of size <span class="math inline">\(n\)</span> and target shape (<span class="math inline">\(h\)</span>, <span class="math inline">\(w\)</span>), we know that <span class="math inline">\(w = n/h\)</span>. To automatically infer one component of the shape, we can place a <code>-1</code> for the shape component that should be inferred automatically. In our case, instead of calling <code>x.reshape(3, 4)</code>, we could have equivalently called <code>x.reshape(-1, 4)</code> or <code>x.reshape(3, -1)</code>.</p>
<p>Practitioners often need to work with tensors initialized to contain all 0s or 1s. [<strong>We can construct a tensor with all elements set to 0</strong>] (<del>or one</del>) and a shape of (2, 3, 4) via the <code>zeros</code> function.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [14]:</pre></div><div id="383cafca" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.122018Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.121194Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.128294Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.127285Z&quot;}}" data-origin_pos="30" data-outputid="d1033ebb-c901-4d98-b333-782c43fdfadb" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>torch.zeros((<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>tensor([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],

        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]])</code></pre>
</div>
</div></div>
<div id="1e967d02" class="cell markdown">
<p>Similarly, we can create a tensor with all 1s by invoking <code>ones</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [16]:</pre></div><div id="0ea249d4" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.132534Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.131716Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.139029Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.138135Z&quot;}}" data-origin_pos="35" data-outputid="295fb3b2-0c1b-47c9-be8e-b16f27fbf7fc" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>torch.ones((<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>tensor([[[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.],
         [1., 1., 1., 1.]]])</code></pre>
</div>
</div></div>
<div id="0615f2d6" class="cell markdown">
<p>We often wish to [<strong>sample each element randomly (and independently)</strong>] from a given probability distribution. For example, the parameters of neural networks are often initialized randomly. The following snippet creates a tensor with elements drawn from a standard Gaussian (normal) distribution with mean 0 and standard deviation 1.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [18]:</pre></div><div id="2254595d" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.143051Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.142388Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.149695Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.148813Z&quot;}}" data-origin_pos="40" data-outputid="0e069922-7b57-45bb-f8d2-9af959c13b89" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>torch.randn(<span class="dv">3</span>, <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>tensor([[ 0.1351, -0.9099, -0.2028,  2.1937],
        [-0.3200, -0.7545,  0.8086, -1.8730],
        [ 0.3929,  0.4931,  0.9114, -0.7072]])</code></pre>
</div>
</div></div>
<div id="d35eda39" class="cell markdown">
<p>Finally, we can construct tensors by [<strong>supplying the exact values for each element</strong>] by supplying (possibly nested) Python list(s) containing numerical literals. Here, we construct a matrix with a list of lists, where the outermost list corresponds to axis 0, and the inner list corresponds to axis 1.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [20]:</pre></div><div id="b26863d8" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.153567Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.153222Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.160436Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.159548Z&quot;}}" data-origin_pos="45" data-outputid="f832b911-6573-4384-d66e-d459ef4e7e2c" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>torch.tensor([[<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>tensor([[2, 1, 4, 3],
        [1, 2, 3, 4],
        [4, 3, 2, 1]])</code></pre>
</div>
</div></div>
<div id="5b589cdb" class="cell markdown">
<section id="indexing-and-slicing" class="level2">
<h2 class="anchored" data-anchor-id="indexing-and-slicing">Indexing and Slicing</h2>
<p>As with Python lists, we can access tensor elements by indexing (starting with 0). To access an element based on its position relative to the end of the list, we can use negative indexing. Finally, we can access whole ranges of indices via slicing (e.g., <code>X[start:stop]</code>), where the returned value includes the first index (<code>start</code>) <em>but not the last</em> (<code>stop</code>). Finally, when only one index (or slice) is specified for a <span class="math inline">\(k^\textrm{th}\)</span>-order tensor, it is applied along axis 0. Thus, in the following code, [<strong><code>[-1]</code> selects the last row and <code>[1:3]</code> selects the second and third rows</strong>].</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [22]:</pre></div><div id="d9049a53" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.164537Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.163812Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.171699Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.170451Z&quot;}}" data-origin_pos="49" data-outputid="7927b279-a900-42d9-9335-b073c4618d8e" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>X[<span class="op">-</span><span class="dv">1</span>], X[<span class="dv">1</span>:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>(tensor([ 8.,  9., 10., 11.]),
 tensor([[ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.]]))</code></pre>
</div>
</div></div>
<div id="5450673b" class="cell markdown">
<p>Beyond reading them, (<strong>we can also <em>write</em> elements of a matrix by specifying indices.</strong>)</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [24]:</pre></div><div id="9246619c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.176047Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.175685Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.182893Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.181890Z&quot;}}" data-origin_pos="52" data-outputid="5799f12e-3394-48f6-f159-0c5c40fd9d79" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>X[<span class="dv">1</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>tensor([[ 0.,  1.,  2.,  3.],
        [ 4.,  5., 17.,  7.],
        [ 8.,  9., 10., 11.]])</code></pre>
</div>
</div></div>
<div id="31f06903" class="cell markdown">
<p>If we want [<strong>to assign multiple elements the same value, we apply the indexing on the left-hand side of the assignment operation.</strong>] For instance, <code>[:2, :]</code> accesses the first and second rows, where <code>:</code> takes all the elements along axis 1 (column). While we discussed indexing for matrices, this also works for vectors and for tensors of more than two dimensions.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [26]:</pre></div><div id="0532f024" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.186970Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.186270Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.193303Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.192338Z&quot;}}" data-origin_pos="56" data-outputid="e7a4c050-40e9-4e5c-82dd-3144eea02486" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>X[:<span class="dv">2</span>, :] <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>X</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>tensor([[12., 12., 12., 12.],
        [12., 12., 12., 12.],
        [ 8.,  9., 10., 11.]])</code></pre>
</div>
</div></div>
<div id="02cdce97" class="cell markdown">
<section id="operations" class="level2">
<h2 class="anchored" data-anchor-id="operations">Operations</h2>
<p>Now that we know how to construct tensors and how to read from and write to their elements, we can begin to manipulate them with various mathematical operations. Among the most useful of these are the <em>elementwise</em> operations. These apply a standard scalar operation to each element of a tensor. For functions that take two tensors as inputs, elementwise operations apply some standard binary operator on each pair of corresponding elements. We can create an elementwise function from any function that maps from a scalar to a scalar.</p>
<p>In mathematical notation, we denote such <em>unary</em> scalar operators (taking one input) by the signature <span class="math inline">\(f: \mathbb{R} \rightarrow \mathbb{R}\)</span>. This just means that the function maps from any real number onto some other real number. Most standard operators, including unary ones like <span class="math inline">\(e^x\)</span>, can be applied elementwise.</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [28]:</pre></div><div id="6dd6724c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.197301Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.196599Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.206136Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.205188Z&quot;}}" data-origin_pos="61" data-outputid="8b319940-fecc-46ad-9e0a-ee4918a8e8b7" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>torch.exp(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>tensor([162754.7969, 162754.7969, 162754.7969, 162754.7969, 162754.7969,
        162754.7969, 162754.7969, 162754.7969,   2980.9580,   8103.0840,
         22026.4648,  59874.1406])</code></pre>
</div>
</div></div>
<div id="b70f353f" class="cell markdown">
<p>Likewise, we denote <em>binary</em> scalar operators, which map pairs of real numbers to a (single) real number via the signature <span class="math inline">\(f: \mathbb{R}, \mathbb{R} \rightarrow \mathbb{R}\)</span>. Given any two vectors <span class="math inline">\(\mathbf{u}\)</span> and <span class="math inline">\(\mathbf{v}\)</span> <em>of the same shape</em>, and a binary operator <span class="math inline">\(f\)</span>, we can produce a vector <span class="math inline">\(\mathbf{c} = F(\mathbf{u},\mathbf{v})\)</span> by setting <span class="math inline">\(c_i \gets f(u_i, v_i)\)</span> for all <span class="math inline">\(i\)</span>, where <span class="math inline">\(c_i, u_i\)</span>, and <span class="math inline">\(v_i\)</span> are the <span class="math inline">\(i^\textrm{th}\)</span> elements of vectors <span class="math inline">\(\mathbf{c}, \mathbf{u}\)</span>, and <span class="math inline">\(\mathbf{v}\)</span>. Here, we produced the vector-valued <span class="math inline">\(F: \mathbb{R}^d, \mathbb{R}^d \rightarrow \mathbb{R}^d\)</span> by <em>lifting</em> the scalar function to an elementwise vector operation. The common standard arithmetic operators for addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and exponentiation (<code>**</code>) have all been <em>lifted</em> to elementwise operations for identically-shaped tensors of arbitrary shape.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [30]:</pre></div><div id="89bc996d" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.210417Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.209741Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.219298Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.218318Z&quot;}}" data-origin_pos="66" data-outputid="5c5cba5a-fbae-4a4f-d326-bfb0c312ace1" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.tensor([<span class="fl">1.0</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">8</span>])</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> torch.tensor([<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>])</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">+</span> y, x <span class="op">-</span> y, x <span class="op">*</span> y, x <span class="op">/</span> y, x <span class="op">**</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>(tensor([ 3.,  4.,  6., 10.]),
 tensor([-1.,  0.,  2.,  6.]),
 tensor([ 2.,  4.,  8., 16.]),
 tensor([0.5000, 1.0000, 2.0000, 4.0000]),
 tensor([ 1.,  4., 16., 64.]))</code></pre>
</div>
</div></div>
<div id="04ae1d38" class="cell markdown">
<p>In addition to elementwise computations, we can also perform linear algebraic operations, such as dot products and matrix multiplications. We will elaborate on these in the Linear Algebra Section.</p>
<p>We can also [<strong><em>concatenate</em> multiple tensors,</strong>] stacking them end-to-end to form a larger one. We just need to provide a list of tensors and tell the system along which axis to concatenate. The example below shows what happens when we concatenate two matrices along rows (axis 0) instead of columns (axis 1). We can see that the first output’s axis-0 length (<span class="math inline">\(6\)</span>) is the sum of the two input tensors’ axis-0 lengths (<span class="math inline">\(3 + 3\)</span>); while the second output’s axis-1 length (<span class="math inline">\(8\)</span>) is the sum of the two input tensors’ axis-1 lengths (<span class="math inline">\(4 + 4\)</span>).</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [32]:</pre></div><div id="43aa9012" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.223534Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.222711Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.233166Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.232145Z&quot;}}" data-origin_pos="71" data-outputid="2fbe190c-0a7b-4f06-d14f-dcc9c33bd650" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> torch.arange(<span class="dv">12</span>, dtype<span class="op">=</span>torch.float32).reshape((<span class="dv">3</span>,<span class="dv">4</span>))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> torch.tensor([[<span class="fl">2.0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]])</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>torch.cat((X, Y), dim<span class="op">=</span><span class="dv">0</span>), torch.cat((X, Y), dim<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [ 2.,  1.,  4.,  3.],
         [ 1.,  2.,  3.,  4.],
         [ 4.,  3.,  2.,  1.]]),
 tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))</code></pre>
</div>
</div></div>
<div id="346adeed" class="cell markdown">
<p>Sometimes, we want to [<strong>construct a binary tensor via <em>logical statements</em>.</strong>] Take <code>X == Y</code> as an example. For each position <code>i, j</code>, if <code>X[i, j]</code> and <code>Y[i, j]</code> are equal, then the corresponding entry in the result takes value <code>1</code>, otherwise it takes value <code>0</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [34]:</pre></div><div id="91d39e58" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.237276Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.236485Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.243133Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.242117Z&quot;}}" data-origin_pos="75" data-outputid="5bbe89b2-44c0-45ec-bf72-b90110a10c24" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">==</span> Y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>tensor([[False,  True, False,  True],
        [False, False, False, False],
        [False, False, False, False]])</code></pre>
</div>
</div></div>
<div id="00448db5" class="cell markdown">
<p>[<strong>Summing all the elements in the tensor</strong>] yields a tensor with only one element.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [36]:</pre></div><div id="080b0125" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.247142Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.246480Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.253117Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.252212Z&quot;}}" data-origin_pos="77" data-outputid="447ffb68-81ac-4f57-d57f-4c098f0f9428" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>X.<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre><code>tensor(66.)</code></pre>
</div>
</div></div>
<div id="e6a78360" class="cell markdown">
<section id="broadcasting" class="level2">
<h2 class="anchored" data-anchor-id="broadcasting">Broadcasting</h2>
<p>By now, you know how to perform elementwise binary operations on two tensors of the same shape. Under certain conditions, even when shapes differ, we can still [<strong>perform elementwise binary operations by invoking the <em>broadcasting mechanism</em>.</strong>] Broadcasting works according to the following two-step procedure: (i) expand one or both arrays by copying elements along axes with length 1 so that after this transformation, the two tensors have the same shape; (ii) perform an elementwise operation on the resulting arrays.</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [38]:</pre></div><div id="be37d2de" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.256932Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.256264Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.263823Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.262881Z&quot;}}" data-origin_pos="81" data-outputid="e65b1e5b-fbea-4cab-eba6-58202b988ada" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.arange(<span class="dv">3</span>).reshape((<span class="dv">3</span>, <span class="dv">1</span>))</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> torch.arange(<span class="dv">2</span>).reshape((<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>a, b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>(tensor([[0],
         [1],
         [2]]),
 tensor([[0, 1]]))</code></pre>
</div>
</div></div>
<div id="6c7e8410" class="cell markdown">
<p>Since <code>a</code> and <code>b</code> are <span class="math inline">\(3\times1\)</span> and <span class="math inline">\(1\times2\)</span> matrices, respectively, their shapes do not match up. Broadcasting produces a larger <span class="math inline">\(3\times2\)</span> matrix by replicating matrix <code>a</code> along the columns and matrix <code>b</code> along the rows before adding them elementwise.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [40]:</pre></div><div id="9f62e827" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.267856Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.267172Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.273497Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.272587Z&quot;}}" data-origin_pos="85" data-outputid="2016b3f0-88ae-4581-fe24-66aa3f53ce35" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">+</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>tensor([[0, 1],
        [1, 2],
        [2, 3]])</code></pre>
</div>
</div></div>
<div id="c5d68609" class="cell markdown">
<section id="saving-memory" class="level2">
<h2 class="anchored" data-anchor-id="saving-memory">Saving Memory</h2>
<p>[<strong>Running operations can cause new memory to be allocated to host results.</strong>] For example, if we write <code>Y = X + Y</code>, we dereference the tensor that <code>Y</code> used to point to and instead point <code>Y</code> at the newly allocated memory. We can demonstrate this issue with Python’s <code>id()</code> function, which gives us the exact address of the referenced object in memory. Note that after we run <code>Y = Y + X</code>, <code>id(Y)</code> points to a different location. That is because Python first evaluates <code>Y + X</code>, allocating new memory for the result and then points <code>Y</code> to this new location in memory.</p>
</section>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [42]:</pre></div><div id="754a7433" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.277697Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.277047Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.283549Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.282613Z&quot;}}" data-origin_pos="87" data-outputid="af739076-95a9-4f92-cdcc-a4f7aa70756e" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>before <span class="op">=</span> <span class="bu">id</span>(Y)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> Y <span class="op">+</span> X</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="bu">id</span>(Y) <span class="op">==</span> before</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>False</code></pre>
</div>
</div></div>
<div id="322d26f5" class="cell markdown">
<p>This might be undesirable for two reasons. First, we do not want to run around allocating memory unnecessarily all the time. In machine learning, we often have hundreds of megabytes of parameters and update all of them multiple times per second. Whenever possible, we want to perform these updates <em>in place</em>. Second, we might point at the same parameters from multiple variables. If we do not update in place, we must be careful to update all of these references, lest we spring a memory leak or inadvertently refer to stale parameters.</p>
</div>
<div id="82880947" class="cell markdown">
<p>Fortunately, (<strong>performing in-place operations</strong>) is easy. We can assign the result of an operation to a previously allocated array <code>Y</code> by using slice notation: <code>Y[:] = &lt;expression&gt;</code>. To illustrate this concept, we overwrite the values of tensor <code>Z</code>, after initializing it, using <code>zeros_like</code>, to have the same shape as <code>Y</code>.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [45]:</pre></div><div id="c4d62609" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.287695Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.286964Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.293078Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.292048Z&quot;}}" data-origin_pos="92" data-outputid="00a541a7-f34a-4c9d-87c6-b2fab8cb935a" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> torch.zeros_like(Y)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'id(Z):'</span>, <span class="bu">id</span>(Z))</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>Z[:] <span class="op">=</span> X <span class="op">+</span> Y</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'id(Z):'</span>, <span class="bu">id</span>(Z))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>id(Z): 140381179266448
id(Z): 140381179266448</code></pre>
</div>
</div></div>
<div id="d745b125" class="cell markdown">
<p>[<strong>If the value of <code>X</code> is not reused in subsequent computations, we can also use <code>X[:] = X + Y</code> or <code>X += Y</code> to reduce the memory overhead of the operation.</strong>]</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [47]:</pre></div><div id="b8c13447" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.296911Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.296361Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.302754Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.301805Z&quot;}}" data-origin_pos="97" data-outputid="601c43ad-08ac-4563-e4f9-9ec0b75a1f7c" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>before <span class="op">=</span> <span class="bu">id</span>(X)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">+=</span> Y</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="bu">id</span>(X) <span class="op">==</span> before</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>True</code></pre>
</div>
</div></div>
<div id="b5f887dd" class="cell markdown">
<section id="conversion-to-other-python-objects" class="level2">
<h2 class="anchored" data-anchor-id="conversion-to-other-python-objects">Conversion to Other Python Objects</h2>
</section>
</div>
<div id="cd057d04" class="cell markdown">
<p>[<strong>Converting to a NumPy tensor (<code>ndarray</code>)</strong>], or vice versa, is easy. The torch tensor and NumPy array will share their underlying memory, and changing one through an in-place operation will also change the other.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [50]:</pre></div><div id="576963aa" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.306812Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.306088Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.312356Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.311478Z&quot;}}" data-origin_pos="103" data-outputid="99d0de0a-2c84-4c1c-bd06-7b7a44ea3538" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> X.numpy()</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> torch.from_numpy(A)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(A), <span class="bu">type</span>(B)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>(numpy.ndarray, torch.Tensor)</code></pre>
</div>
</div></div>
<div id="b2def017" class="cell markdown">
<p>To (<strong>convert a size-1 tensor to a Python scalar</strong>), we can invoke the <code>item</code> function or Python’s built-in functions.</p>
</div>
<div class="cell-container"><div class="cell-decorator"><pre>In [52]:</pre></div><div id="388c5252" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;execution&quot;,&quot;value&quot;:{&quot;iopub.execute_input&quot;:&quot;2023-08-18T19:32:57.316471Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-08-18T19:32:57.315825Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-08-18T19:32:57.322867Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-08-18T19:32:57.322007Z&quot;}}" data-origin_pos="108" data-outputid="9be47dd0-c5b6-49ff-d933-1bc75fdd2f42" data-tab="[&quot;pytorch&quot;]">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.tensor([<span class="fl">3.5</span>])</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>a, a.item(), <span class="bu">float</span>(a), <span class="bu">int</span>(a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>(tensor([3.5000]), 3.5, 3.5, 3)</code></pre>
</div>
</div></div>
<div id="9373077d" class="cell markdown">
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>The tensor class is the main interface for storing and manipulating data in deep learning libraries. Tensors provide a variety of functionalities including construction routines; indexing and slicing; basic mathematics operations; broadcasting; memory-efficient assignment; and conversion to and from other Python objects.</p>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<ol type="1">
<li>Run the code in this section. Change the conditional statement <code>X == Y</code> to <code>X &lt; Y</code> or <code>X &gt; Y</code>, and then see what kind of tensor you can get.</li>
<li>Replace the two tensors that operate by element in the broadcasting mechanism with other shapes, e.g., 3-dimensional tensors. Is the result the same as expected?</li>
</ol>
</section>
</div>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>  </div> <!-- /content --> 
  
</body></html>